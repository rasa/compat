// SPDX-FileCopyrightText: Copyright Â© 2025 Ross Smith II <ross@smithii.com>
// SPDX-License-Identifier: MIT

package compat

import (
	"os"
)

// Chmod changes the mode of the named file to mode.
// If the file is a symbolic link, it changes the mode of the link's target.
// If there is an error, it will be of type [*PathError].
//
// A different subset of the mode bits are used, depending on the
// operating system.
//
// On Unix, the mode's permission bits, [ModeSetuid], [ModeSetgid], and
// [ModeSticky] are used.
//
// On Windows, the mode's permission bits are used to set the appropriate
// ACL entries.
//
// In addition, the 0o200 bit (owner writable) is used to
// control whether the file's read-only attribute is set or cleared.
// For compatibility with Go 1.12 and earlier, use a non-zero mode.
//
// On Plan 9, the mode's permission bits, [ModeAppend], [ModeExclusive],
// and [ModeTemporary] are used.
func Chmod(name string, mode os.FileMode, opts ...Option) error {
	fopts := Options{}

	for _, opt := range opts {
		opt(&fopts)
	}

	return chmod(name, mode, fopts.readOnlyMode)
}

// Create creates or truncates the named file. If the file already exists,
// it is truncated. If the file does not exist, it is created with mode 0o666
// (before umask). If successful, methods on the returned File can
// be used for I/O; the associated file descriptor has mode [O_RDWR].
// The directory containing the file must already exist.
// If there is an error, it will be of type [*PathError].
func Create(name string, opts ...Option) (*os.File, error) {
	// https://github.com/golang/go/blob/master/src/os/file.go#L393
	// return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)

	fopts := Options{
		fileMode: CreatePerm,
		flags:    os.O_CREATE | os.O_TRUNC,
	}

	for _, opt := range opts {
		opt(&fopts)
	}

	if fopts.flags&os.O_WRONLY != os.O_WRONLY {
		fopts.flags |= os.O_RDWR
	}

	if IsWindows {
		if fopts.readOnlyMode != ReadOnlyModeSet {
			fopts.flags |= O_FILE_FLAG_NO_RO_ATTR
		}
	}

	return create(name, fopts.fileMode, fopts.flags)
}

// CreateTemp creates a new temporary file in the directory dir,
// opens the file for reading and writing, and returns the resulting file.
// The filename is generated by taking pattern and adding a random string to the end.
// If pattern includes a "*", the random string replaces the last "*".
// The file is created with mode 0o600 (before umask).
// If dir is the empty string, CreateTemp uses the default directory for temporary files, as returned by [TempDir].
// Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file.
// The caller can use the file's Name method to find the pathname of the file.
// It is the caller's responsibility to remove the file when it is no longer needed.
func CreateTemp(dir, pattern string, opts ...Option) (*os.File, error) {
	fopts := Options{
		fileMode: CreateTempPerm,
		flags:    os.O_CREATE | os.O_TRUNC,
	}

	for _, opt := range opts {
		opt(&fopts)
	}

	if fopts.flags&os.O_WRONLY != os.O_WRONLY {
		fopts.flags |= os.O_RDWR
	}

	if IsWindows {
		if fopts.readOnlyMode != ReadOnlyModeSet {
			fopts.flags |= O_FILE_FLAG_NO_RO_ATTR
		}
	}

	return createTemp(dir, pattern, fopts.fileMode, fopts.flags)
}

// Fchmod changes the mode of the file to mode.
// If there is an error, it will be of type [*PathError].
func Fchmod(f *os.File, mode os.FileMode, opts ...Option) error {
	fopts := Options{}

	for _, opt := range opts {
		opt(&fopts)
	}

	return fchmod(f, mode, fopts.readOnlyMode)
}

// Mkdir creates a new directory with the specified name and perm's permission
// bits (before umask).
// If there is an error, it will be of type [*PathError].
func Mkdir(name string, perm os.FileMode) error {
	return mkdir(name, perm)
}

// MkdirAll creates a directory named path,
// along with any necessary parents, and returns nil,
// or else returns an error.
// The perm's permission bits (before umask) are used for all
// directories that MkdirAll creates.
// If path is already a directory, MkdirAll does nothing
// and returns nil.
func MkdirAll(path string, perm os.FileMode) error {
	return mkdirAll(path, perm)
}

// MkdirTemp creates a new temporary directory in the directory dir
// and returns the pathname of the new directory.
// The new directory's name is generated by adding a random string to the end of pattern.
// If pattern includes a "*", the random string replaces the last "*" instead.
// The directory is created with mode 0o700 (before umask).
// If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir.
// Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.
// It is the caller's responsibility to remove the directory when it is no longer needed.
func MkdirTemp(dir, pattern string, opts ...Option) (string, error) {
	fopts := Options{
		fileMode: MkdirTempPerm,
	}
	for _, opt := range opts {
		opt(&fopts)
	}

	return mkdirTemp(dir, pattern, fopts.fileMode)
}

// OpenFile is the generalized open call; most users will use Open
// or Create instead. It opens the named file with specified flag
// ([O_RDONLY] etc.). If the file does not exist, and the [O_CREATE] flag
// is passed, it is created with perm's permission bits (before umask);
// the containing directory must exist. If successful,
// methods on the returned File can be used for I/O.
// If there is an error, it will be of type [*PathError].
func OpenFile(name string, flag int, perm os.FileMode, opts ...Option) (*os.File, error) {
	fopts := Options{
		fileMode: perm,
		flags:    flag,
	}
	for _, opt := range opts {
		opt(&fopts)
	}

	if IsWindows {
		if fopts.readOnlyMode != ReadOnlyModeSet {
			fopts.flags |= O_FILE_FLAG_NO_RO_ATTR
		}
	}

	return openFile(name, fopts.flags, fopts.fileMode)
}

// Remove removes the named file or directory.
// If there is an error, it will be of type [*PathError].
func Remove(name string) error {
	return remove(name)
}

// RemoveAll removes path and any children it contains.
// It removes everything it can but returns the first error
// it encounters. If the path does not exist, RemoveAll
// returns nil (no error).
// If there is an error, it will be of type [*PathError].
func RemoveAll(path string, opts ...Option) error {
	return removeAll(path, opts...)
}

// Symlink creates newname as a symbolic link to oldname.
// On Windows, a symlink to a non-existent oldname creates a file symlink;
// if oldname is later created as a directory the symlink will not work.
// If there is an error, it will be of type *LinkError.
func Symlink(oldname, newname string, opts ...Option) error {
	fopts := Options{}
	for _, opt := range opts {
		opt(&fopts)
	}

	return symlink(oldname, newname, fopts.setSymlinkOwner)
}
