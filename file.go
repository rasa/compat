// SPDX-FileCopyrightText: Copyright Â© 2025 Ross Smith II <ross@smithii.com>
// SPDX-License-Identifier: MIT

package compat

import (
	"os"
)

// Chmod changes the mode of the named file to mode.
// If the file is a symbolic link, it changes the mode of the link's target.
// If there is an error, it will be of type [*PathError].
//
// A different subset of the mode bits are used, depending on the
// operating system.
//
// On Unix, the mode's permission bits, [ModeSetuid], [ModeSetgid], and
// [ModeSticky] are used.
//
// On Windows, the mode's permission bits are used to set the appropriate
// ACL entries.
//
// In addition, the 0o200 bit (owner writable) is used to
// control whether the file's read-only attribute is set or cleared.
// For compatibility with Go 1.12 and earlier, use a non-zero mode.
//
// On Plan 9, the mode's permission bits, [ModeAppend], [ModeExclusive],
// and [ModeTemporary] are used.
func Chmod(name string, mode os.FileMode) error {
	return chmod(name, mode)
}

// Create creates or truncates the named file. If the file already exists,
// it is truncated. If the file does not exist, it is created with mode 0o666
// (before umask). If successful, methods on the returned File can
// be used for I/O; the associated file descriptor has mode [O_RDWR].
// The directory containing the file must already exist.
// If there is an error, it will be of type [*PathError].
func Create(name string, opts ...Option) (*os.File, error) {
	// https://github.com/golang/go/blob/master/src/os/file.go#L393
	// return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)

	fopts := Options{
		keepFileMode: true,
		useFileMode:  CreatePerm,
		flag:         os.O_RDWR | os.O_CREATE | os.O_TRUNC,
	}

	for _, opt := range opts {
		opt(&fopts)
	}

	return create(name, fopts.useFileMode, fopts.flag)
}

// CreateTemp creates a new temporary file in the directory dir,
// opens the file for reading and writing, and returns the resulting file.
// The filename is generated by taking pattern and adding a random string to the end.
// If pattern includes a "*", the random string replaces the last "*".
// The file is created with mode 0o600 (before umask).
// If dir is the empty string, CreateTemp uses the default directory for temporary files, as returned by [TempDir].
// Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file.
// The caller can use the file's Name method to find the pathname of the file.
// It is the caller's responsibility to remove the file when it is no longer needed.
func CreateTemp(dir, pattern string, opts ...Option) (*os.File, error) {
	fopts := Options{
		useFileMode: CreateTempPerm,
		flag:        os.O_CREATE,
	}
	for _, opt := range opts {
		opt(&fopts)
	}

	return createTemp(dir, pattern, fopts.useFileMode, fopts.flag)
}

// Mkdir creates a new directory with the specified name and perm's permission
// bits (before umask).
// If there is an error, it will be of type [*PathError].
func Mkdir(name string, perm os.FileMode) error {
	return mkdir(name, perm)
}

// MkdirAll creates a directory named path,
// along with any necessary parents, and returns nil,
// or else returns an error.
// The perm's permission bits (before umask) are used for all
// directories that MkdirAll creates.
// If path is already a directory, MkdirAll does nothing
// and returns nil.
func MkdirAll(path string, perm os.FileMode) error {
	return mkdirAll(path, perm)
}

// MkdirTemp creates a new temporary directory in the directory dir
// and returns the pathname of the new directory.
// The new directory's name is generated by adding a random string to the end of pattern.
// If pattern includes a "*", the random string replaces the last "*" instead.
// The directory is created with mode 0o700 (before umask).
// If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir.
// Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.
// It is the caller's responsibility to remove the directory when it is no longer needed.
func MkdirTemp(dir, pattern string, opts ...Option) (string, error) {
	fopts := FileOptions{
		useFileMode: MkdirTempPerm,
	}
	for _, opt := range opts {
		opt(&fopts)
	}

	return mkdirTemp(dir, pattern, fopts.useFileMode)
}

// OpenFile is the generalized open call; most users will use Open
// or Create instead. It opens the named file with specified flag
// ([O_RDONLY] etc.). If the file does not exist, and the [O_CREATE] flag
// is passed, it is created with perm's permission bits (before umask);
// the containing directory must exist. If successful,
// methods on the returned File can be used for I/O.
// If there is an error, it will be of type [*PathError].
func OpenFile(name string, flag int, perm os.FileMode) (*os.File, error) {
	return openFile(name, flag, perm)
}

// Remove removes the named file or directory.
// If there is an error, it will be of type [*PathError].
func Remove(name string) error {
	return remove(name)
}

// RemoveAll removes path and any children it contains.
// It removes everything it can but returns the first error
// it encounters. If the path does not exist, RemoveAll
// returns nil (no error).
// If there is an error, it will be of type [*PathError].
func RemoveAll(path string) error {
	return removeAll(path)
}

// Symlink creates newname as a symbolic link to oldname.
// On Windows, a symlink to a non-existent oldname creates a file symlink;
// if oldname is later created as a directory the symlink will not work.
// If there is an error, it will be of type *LinkError.
func Symlink(oldname, newname string) error {
	return symlink(oldname, newname)
}

// WriteFile writes data to the named file, creating it if necessary.
// If the file does not exist, WriteFile creates it using perm's permissions bits (before umask);
// otherwise WriteFile truncates it before writing, without changing permissions.
// Since WriteFile requires multiple system calls to complete, a failure mid-operation
// can leave the file in a partially written state. Use WriteFileAtomic() if this
// is a concern.
func WriteFile(name string, data []byte, perm os.FileMode, opts ...Option) error {
	fopts := Options{
		// keepFileMode: true,
		useFileMode: perm,
		flag:        0, // O_RDWR | O_CREATE | O_TRUNC,
	}

	for _, opt := range opts {
		opt(&fopts)
	}

	return writeFile(name, data, perm, 0)
}
